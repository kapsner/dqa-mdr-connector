<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dqa_mdr_connector.update_mdr API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dqa_mdr_connector.update_mdr</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python

# dqa-mdr-connector: Connecting the MIRACUM-MDR with the DQA-Tool
# Copyright (C) 2022 Universitätsklinikum Erlangen
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

__author__ = &#34;Lorenz A. Kapsner, Moritz Stengel&#34;
__copyright__ = &#34;Universitätsklinikum Erlangen&#34;

from operator import length_hint
import os
import requests
import urllib.parse as up
import pandas as pd
import posixpath
from requests.api import head, request
from requests.models import HTTPBasicAuth
import json
import logging
import copy

from dqa_mdr_connector.api_connection import ApiConnector
from dqa_mdr_connector.slot_create import slot_create_dqa_value

# api doc: https://rest.demo.dataelementhub.de/swagger-ui/index.html?configUrl=/v3/api-docs/swagger-config
# dicovery doc: https://www.keycloak.org/docs/4.8/authorization_services/#_service_authorization_api


class UpdateMDR(ApiConnector):

    def __init__(
            self,
            csv_file: str,
            separator: str = &#34;,&#34;,
            main_system_name: str = &#34;i2b2&#34;,
            main_system_type: str = &#34;postgres&#34;,
            de_fhir_paths: list = None,
            **kwargs
    ):

        # if creating new namespace, arg &#34;namespace_definition&#34; is required
        if &#34;namespace_definition&#34; in kwargs.keys():
            self.namespace_definition = kwargs.pop(&#34;namespace_definition&#34;)

        # initialize apiconnector
        super().__init__(download=False, **kwargs)

        self.de_fhir_paths = de_fhir_paths

        self.csv_file_name = csv_file

        # init templates
        self.init_templates()

        # read database
        self.read_csv_mdr(separator=separator)

        # MDR = self.database
        # now create main_system_mdr with unique dataelements only (no duplicate designation)
        # as defined by arg &#39;main_system_name&#39; and &#39;main_system_type&#39;
        self.main_system_mdr = self.database[
            (self.database[&#34;source_system_name&#34;] == main_system_name) &amp;
            (self.database[&#34;source_system_type&#34;] == main_system_type)]

        if len(self.main_system_mdr) != \
                len(self.main_system_mdr[[&#34;designation&#34;, &#34;key&#34;, &#34;variable_name&#34;]]):
            raise Exception(
                &#34;main_system_mdr contains duplicate entries of data elements.&#34;)

    def __call__(self):

        # define some empty containers for later
        mdr_de_designations = {}

        # test, if namespace already exists in remote-mdr
        # if namespace exists, self.ns_id is set
        self.check_if_namespace_exists()

        if self.ns_id is None:
            logging.info(&#34;Namespace &#39;&#39; does not exist.\n&#34;.format(
                self.namespace_designation))

            msg = &#34;No or multiple namespaces found at &#39;{}&#39; for namespace_designation &#39;{}&#39;.\n \
                Creating new namespace.&#34;.format(
                self.base_url,
                self.namespace_designation
            )
            logging.warning(msg)

            create_ns = {
                &#34;identification&#34;: {
                    &#34;elementType&#34;: &#34;NAMESPACE&#34;,
                    &#34;hideNamespace&#34;: True,
                    &#34;status&#34;: &#34;RELEASED&#34;
                },
                &#34;definitions&#34;: [
                    {
                        &#34;designation&#34;: self.namespace_designation,
                        &#34;definition&#34;: self.namespace_definition,
                        &#34;language&#34;: &#34;en&#34;
                    }
                ]
            }

            response = requests.post(
                url=self.base_url + &#34;namespaces/&#34;,
                data=json.dumps(create_ns),
                headers=self.header
            )

            # log response
            logging.info(response)

            # now, namespace exists, set self.ns_id
            self.check_if_namespace_exists()

        else:
            logging.info(&#34;Namespace &#39;{}&#39; already exists.\n&#34;.format(
                self.namespace_designation))
            namespace_dataelement_urns = self.get_namespace_urns(
                ns_id=self.ns_id)

            urn_designation_mapping = {}

            # get designation for each urn
            for _dataelement_urn in namespace_dataelement_urns:
                # get data element from mdr
                response, ns_dataelement_url = self.get_element_by_urn(
                    urn=_dataelement_urn
                )

                # check for fhir path
                fhir_path = [s for s in response[&#34;slots&#34;] if s[&#34;name&#34;] == &#34;fhir-path&#34;]
                if len(fhir_path) == 1:
                    if not fhir_path[0][&#34;value&#34;] in self.de_fhir_paths:
                        # continue loop, if this dataelement is not wanted
                        continue
                else:
                    continue

                multi_designation_list = []

                for _element in response[&#34;definitions&#34;]:
                    multi_designation_list.append(_element[&#34;designation&#34;])

                urn_designation_mapping[_dataelement_urn] = {
                    &#34;designation&#34;: multi_designation_list,
                    &#34;valueDomainUrn&#34;: response[&#34;valueDomainUrn&#34;]
                }

            # lookup -&gt; get elements of csv-file that are already present in mdr
            # mdr data element designations
            for _urn, _de_designations in urn_designation_mapping.items():
                while True:
                    for _de_designation in _de_designations[&#34;designation&#34;]:
                        if _de_designation in self.main_system_mdr[&#34;designation&#34;].values:
                            mdr_de_designations[_de_designation] = _urn
                            # if correct designation found within set of designations,
                            # skip for-loop
                            break
                    break

        # update existing dataelements
        for _i, _row in self.main_system_mdr.iterrows():
            _designation = _row[&#34;designation&#34;]
            _definition = _row[&#34;definition&#34;]

            logging.info(&#34;Dataelement: {}\n\n&#34;.format(_designation))

            # define basic json container
            de_basetemp = copy.deepcopy(self._de_json_template)
            # get _ns_urn elswhere, write to &#34;self.ns_urn&#34;
            de_basetemp[&#34;identification&#34;][&#34;namespaceUrn&#34;] = self.ns_urn

            # fill definition template
            de_definition_temp = copy.deepcopy(
                self._de_definition_json_template)
            de_definition_temp[&#34;designation&#34;] = _designation
            de_definition_temp[&#34;definition&#34;] = _definition

            # add definition template to basetemp
            de_basetemp[&#34;definitions&#34;].append(de_definition_temp)

            # create and modify temporary slot list element
            # (which is actually our dict from the slot_template)
            create_slot_tmp = copy.deepcopy(
                self._de_slot_template
            )
            create_slot_tmp[&#34;name&#34;] = &#34;dqa&#34;
            create_slot_tmp[&#34;value&#34;] = slot_create_dqa_value(
                mdr=self.database,
                mdr_row=_row
            )

            # append slot_temp to slots-list
            de_basetemp[&#34;slots&#34;] = de_basetemp[&#34;slots&#34;] + [create_slot_tmp]

            if _designation in mdr_de_designations.keys():
                # update data element on API (PUT)
                _urn = mdr_de_designations[_designation]
                _valuedomainurn = urn_designation_mapping[_urn][&#34;valueDomainUrn&#34;]
                de_basetemp[&#34;valueDomainUrn&#34;] = _valuedomainurn

                # get all existing slots but the &#34;dqa&#34;-slot
                response, ns_dataelement_url = self.get_element_by_urn(
                    urn=_urn
                )
                de_slot_items = [s for s in response[&#34;slots&#34;] if s[&#34;name&#34;] != &#34;dqa&#34;]

                de_basetemp[&#34;slots&#34;] = de_basetemp[&#34;slots&#34;] + de_slot_items

                element_url = up.urljoin(
                    self.base_url,
                    posixpath.join(
                        &#34;element&#34;,
                        _urn
                    )
                )
                response = requests.put(
                    url=element_url,
                    data=json.dumps(de_basetemp),
                    headers=self.header
                )

            else:
                # create new data element on API (POST)
                # fill valuetype
                valuedomain_temp = copy.deepcopy(eval(
                    &#34;self._de_valuedomain_template_&#34; +
                    _row[&#34;variable_type&#34;]
                ))

                # json.loads()
                try:
                    _constraints = json.loads(_row[&#34;constraints&#34;])

                    if _row[&#34;variable_type&#34;] == &#34;string&#34;:
                        # do some logic here to fill string-specific field in template
                        valuedomain_temp[&#34;text&#34;][&#34;regEx&#34;] = _constraints[&#34;regex&#34;]
                        valuedomain_temp[&#34;text&#34;][&#34;useRegEx&#34;] = True

                    elif _row[&#34;variable_type&#34;] == &#34;datetime&#34;:
                        # do some logic here to fill datetime-specific field in template
                        valuedomain_temp[&#34;datetime&#34;][&#34;date&#34;] = _constraints[&#34;date&#34;][&#34;date&#34;]
                        valuedomain_temp[&#34;datetime&#34;][&#34;time&#34;] = _constraints[&#34;date&#34;][&#34;time&#34;]
                        valuedomain_temp[&#34;datetime&#34;][&#34;hourFormat&#34;] = _constraints[&#34;date&#34;][&#34;hourFormat&#34;]

                    elif _row[&#34;variable_type&#34;] == &#34;enumerated&#34;:
                        # do some logic here to fill enumerated-specific field in template
                        value_set = _constraints[&#34;value_set&#34;].split(
                            &#34;, &#34;)

                        # init enumerated-form here:
                        enumerated_value_set = []

                        # loop over value_set
                        for _val in value_set:
                            enumerated_value_set.append({
                                &#34;definitions&#34;: [{
                                    &#34;designation&#34;: _val,
                                    &#34;definition&#34;: _val,
                                    &#34;language&#34;: &#34;en&#34;
                                }],
                                &#34;value&#34;: _val
                            })

                        valuedomain_temp[&#34;permittedValues&#34;] = enumerated_value_set

                    elif _row[&#34;variable_type&#34;] in [&#34;float&#34;, &#34;integer&#34;]:
                        valuedomain_temp[&#34;numeric&#34;][&#34;type&#34;] = _row[&#34;variable_type&#34;].upper(
                        )
                        # fill numeric-specific field in template
                        valuedomain_temp[&#34;numeric&#34;][&#34;minimum&#34;] = _constraints[&#34;range&#34;][&#34;min&#34;]
                        valuedomain_temp[&#34;numeric&#34;][&#34;maximum&#34;] = _constraints[&#34;range&#34;][&#34;max&#34;]
                        valuedomain_temp[&#34;numeric&#34;][&#34;unitOfMeasure&#34;] = _constraints[&#34;range&#34;][&#34;unit&#34;]

                        valuedomain_temp[&#34;numeric&#34;][&#34;useMinimum&#34;] = True
                        valuedomain_temp[&#34;numeric&#34;][&#34;useMaximum&#34;] = True

                    # add definition template to basetemp
                    de_basetemp[&#34;valueDomain&#34;] = valuedomain_temp

                except Exception as e:
                    logging.error(e)
                    valuedomain_temp = copy.deepcopy(
                        self._de_valuedomain_template_)
                    valuedomain_temp[&#34;text&#34;][&#34;useRegEx&#34;] = False
                    de_basetemp[&#34;valueDomain&#34;] = valuedomain_temp

                element_url = up.urljoin(
                    self.base_url,
                    &#34;element&#34;
                )
                response = requests.post(
                    url=element_url,
                    data=json.dumps(de_basetemp),
                    headers=self.header
                )
                logging.info(response)

    def read_csv_mdr(self, separator: str):
        if separator not in [&#34;;&#34;, &#34;,&#34;]:
            msg = &#34;Separator of CSV-file must be &#39;;&#39; or &#39;,&#39;&#34;
            logging.error(msg)
            raise Exception(msg)
        self.database = pd.read_csv(
            filepath_or_buffer=self.csv_file_name,
            sep=separator,
            keep_default_na=False
        )

    @staticmethod
    def post_to_api(url, data, header):
        logging.info(&#34;API post: {}&#34;.format(url))
        r = requests.post(
            url=url,
            data=data,
            headers=header
        )
        return r

    def init_template_elements(self):

        self._de_definition_json_template = {
            &#34;designation&#34;: [],
            &#34;definition&#34;: [],
            &#34;language&#34;: &#34;en&#34;
        }

        self._de_valuedomain_template_string = {
            &#34;type&#34;: &#34;STRING&#34;,
            &#34;text&#34;: {
                &#34;useRegEx&#34;: &#34;&#34;,
                &#34;regEx&#34;: &#34;&#34;,
                &#34;useMaximumLength&#34;: True,
                &#34;maximumLength&#34;: int()
            }
        }

        # use &#34;string&#34;, when no &#34;variable_type&#34; defined
        self._de_valuedomain_template_ = self._de_valuedomain_template_string

        # update datetime template correctly #done
        # above: fill correctly with info from csv
        self._de_valuedomain_template_datetime = {
            &#34;type&#34;: &#34;DATETIME&#34;,
            &#34;datetime&#34;: {
                &#34;date&#34;: &#34;&#34;,
                &#34;time&#34;: &#34;&#34;,
                &#34;hourFormat&#34;: &#34;&#34;
            }
        }

        # update enumerated template correctly #not possible in current status
        # above: fill correctly with info from csv
        self._de_valuedomain_template_enumerated = {
            &#34;type&#34;: &#34;ENUMERATED&#34;,
            &#34;permittedValues&#34;: &#34;&#34;
        }

        # update float template correctly
        # above: fill correctly with info from csv
        self._de_valuedomain_template_float = {
            &#34;type&#34;: &#34;NUMERIC&#34;,
            &#34;numeric&#34;: {
                &#34;type&#34;: &#34;&#34;,
                &#34;useMinimum&#34;: &#34;&#34;,  # bool
                &#34;useMaximum&#34;: &#34;&#34;,  # bool
                &#34;unitOfMeasure&#34;: &#34;&#34;,  # string
                &#34;minimum&#34;: &#34;&#34;,  # numeric/float
                &#34;maximum&#34;: &#34;&#34;  # numeric/float
            }
        }

        self._de_valuedomain_template_integer = self._de_valuedomain_template_float

        self._de_slot_template = {
            &#34;name&#34;: &#34;&#34;,
            &#34;value&#34;: &#34;&#34;
        }

    def init_templates(self):
        # init template elements
        self.init_template_elements()

        # data element template
        self._de_json_template = {
            &#34;identification&#34;: {
                &#34;elementType&#34;: &#34;DATAELEMENT&#34;,
                &#34;namespaceUrn&#34;: &#34;&#34;,
                &#34;status&#34;: &#34;RELEASED&#34;
            },
            &#34;definitions&#34;: [],
            &#34;slots&#34;: [],
            &#34;conceptAssociations&#34;: []
        }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dqa_mdr_connector.update_mdr.UpdateMDR"><code class="flex name class">
<span>class <span class="ident">UpdateMDR</span></span>
<span>(</span><span>csv_file: str, separator: str = ',', main_system_name: str = 'i2b2', main_system_type: str = 'postgres', de_fhir_paths: list = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UpdateMDR(ApiConnector):

    def __init__(
            self,
            csv_file: str,
            separator: str = &#34;,&#34;,
            main_system_name: str = &#34;i2b2&#34;,
            main_system_type: str = &#34;postgres&#34;,
            de_fhir_paths: list = None,
            **kwargs
    ):

        # if creating new namespace, arg &#34;namespace_definition&#34; is required
        if &#34;namespace_definition&#34; in kwargs.keys():
            self.namespace_definition = kwargs.pop(&#34;namespace_definition&#34;)

        # initialize apiconnector
        super().__init__(download=False, **kwargs)

        self.de_fhir_paths = de_fhir_paths

        self.csv_file_name = csv_file

        # init templates
        self.init_templates()

        # read database
        self.read_csv_mdr(separator=separator)

        # MDR = self.database
        # now create main_system_mdr with unique dataelements only (no duplicate designation)
        # as defined by arg &#39;main_system_name&#39; and &#39;main_system_type&#39;
        self.main_system_mdr = self.database[
            (self.database[&#34;source_system_name&#34;] == main_system_name) &amp;
            (self.database[&#34;source_system_type&#34;] == main_system_type)]

        if len(self.main_system_mdr) != \
                len(self.main_system_mdr[[&#34;designation&#34;, &#34;key&#34;, &#34;variable_name&#34;]]):
            raise Exception(
                &#34;main_system_mdr contains duplicate entries of data elements.&#34;)

    def __call__(self):

        # define some empty containers for later
        mdr_de_designations = {}

        # test, if namespace already exists in remote-mdr
        # if namespace exists, self.ns_id is set
        self.check_if_namespace_exists()

        if self.ns_id is None:
            logging.info(&#34;Namespace &#39;&#39; does not exist.\n&#34;.format(
                self.namespace_designation))

            msg = &#34;No or multiple namespaces found at &#39;{}&#39; for namespace_designation &#39;{}&#39;.\n \
                Creating new namespace.&#34;.format(
                self.base_url,
                self.namespace_designation
            )
            logging.warning(msg)

            create_ns = {
                &#34;identification&#34;: {
                    &#34;elementType&#34;: &#34;NAMESPACE&#34;,
                    &#34;hideNamespace&#34;: True,
                    &#34;status&#34;: &#34;RELEASED&#34;
                },
                &#34;definitions&#34;: [
                    {
                        &#34;designation&#34;: self.namespace_designation,
                        &#34;definition&#34;: self.namespace_definition,
                        &#34;language&#34;: &#34;en&#34;
                    }
                ]
            }

            response = requests.post(
                url=self.base_url + &#34;namespaces/&#34;,
                data=json.dumps(create_ns),
                headers=self.header
            )

            # log response
            logging.info(response)

            # now, namespace exists, set self.ns_id
            self.check_if_namespace_exists()

        else:
            logging.info(&#34;Namespace &#39;{}&#39; already exists.\n&#34;.format(
                self.namespace_designation))
            namespace_dataelement_urns = self.get_namespace_urns(
                ns_id=self.ns_id)

            urn_designation_mapping = {}

            # get designation for each urn
            for _dataelement_urn in namespace_dataelement_urns:
                # get data element from mdr
                response, ns_dataelement_url = self.get_element_by_urn(
                    urn=_dataelement_urn
                )

                # check for fhir path
                fhir_path = [s for s in response[&#34;slots&#34;] if s[&#34;name&#34;] == &#34;fhir-path&#34;]
                if len(fhir_path) == 1:
                    if not fhir_path[0][&#34;value&#34;] in self.de_fhir_paths:
                        # continue loop, if this dataelement is not wanted
                        continue
                else:
                    continue

                multi_designation_list = []

                for _element in response[&#34;definitions&#34;]:
                    multi_designation_list.append(_element[&#34;designation&#34;])

                urn_designation_mapping[_dataelement_urn] = {
                    &#34;designation&#34;: multi_designation_list,
                    &#34;valueDomainUrn&#34;: response[&#34;valueDomainUrn&#34;]
                }

            # lookup -&gt; get elements of csv-file that are already present in mdr
            # mdr data element designations
            for _urn, _de_designations in urn_designation_mapping.items():
                while True:
                    for _de_designation in _de_designations[&#34;designation&#34;]:
                        if _de_designation in self.main_system_mdr[&#34;designation&#34;].values:
                            mdr_de_designations[_de_designation] = _urn
                            # if correct designation found within set of designations,
                            # skip for-loop
                            break
                    break

        # update existing dataelements
        for _i, _row in self.main_system_mdr.iterrows():
            _designation = _row[&#34;designation&#34;]
            _definition = _row[&#34;definition&#34;]

            logging.info(&#34;Dataelement: {}\n\n&#34;.format(_designation))

            # define basic json container
            de_basetemp = copy.deepcopy(self._de_json_template)
            # get _ns_urn elswhere, write to &#34;self.ns_urn&#34;
            de_basetemp[&#34;identification&#34;][&#34;namespaceUrn&#34;] = self.ns_urn

            # fill definition template
            de_definition_temp = copy.deepcopy(
                self._de_definition_json_template)
            de_definition_temp[&#34;designation&#34;] = _designation
            de_definition_temp[&#34;definition&#34;] = _definition

            # add definition template to basetemp
            de_basetemp[&#34;definitions&#34;].append(de_definition_temp)

            # create and modify temporary slot list element
            # (which is actually our dict from the slot_template)
            create_slot_tmp = copy.deepcopy(
                self._de_slot_template
            )
            create_slot_tmp[&#34;name&#34;] = &#34;dqa&#34;
            create_slot_tmp[&#34;value&#34;] = slot_create_dqa_value(
                mdr=self.database,
                mdr_row=_row
            )

            # append slot_temp to slots-list
            de_basetemp[&#34;slots&#34;] = de_basetemp[&#34;slots&#34;] + [create_slot_tmp]

            if _designation in mdr_de_designations.keys():
                # update data element on API (PUT)
                _urn = mdr_de_designations[_designation]
                _valuedomainurn = urn_designation_mapping[_urn][&#34;valueDomainUrn&#34;]
                de_basetemp[&#34;valueDomainUrn&#34;] = _valuedomainurn

                # get all existing slots but the &#34;dqa&#34;-slot
                response, ns_dataelement_url = self.get_element_by_urn(
                    urn=_urn
                )
                de_slot_items = [s for s in response[&#34;slots&#34;] if s[&#34;name&#34;] != &#34;dqa&#34;]

                de_basetemp[&#34;slots&#34;] = de_basetemp[&#34;slots&#34;] + de_slot_items

                element_url = up.urljoin(
                    self.base_url,
                    posixpath.join(
                        &#34;element&#34;,
                        _urn
                    )
                )
                response = requests.put(
                    url=element_url,
                    data=json.dumps(de_basetemp),
                    headers=self.header
                )

            else:
                # create new data element on API (POST)
                # fill valuetype
                valuedomain_temp = copy.deepcopy(eval(
                    &#34;self._de_valuedomain_template_&#34; +
                    _row[&#34;variable_type&#34;]
                ))

                # json.loads()
                try:
                    _constraints = json.loads(_row[&#34;constraints&#34;])

                    if _row[&#34;variable_type&#34;] == &#34;string&#34;:
                        # do some logic here to fill string-specific field in template
                        valuedomain_temp[&#34;text&#34;][&#34;regEx&#34;] = _constraints[&#34;regex&#34;]
                        valuedomain_temp[&#34;text&#34;][&#34;useRegEx&#34;] = True

                    elif _row[&#34;variable_type&#34;] == &#34;datetime&#34;:
                        # do some logic here to fill datetime-specific field in template
                        valuedomain_temp[&#34;datetime&#34;][&#34;date&#34;] = _constraints[&#34;date&#34;][&#34;date&#34;]
                        valuedomain_temp[&#34;datetime&#34;][&#34;time&#34;] = _constraints[&#34;date&#34;][&#34;time&#34;]
                        valuedomain_temp[&#34;datetime&#34;][&#34;hourFormat&#34;] = _constraints[&#34;date&#34;][&#34;hourFormat&#34;]

                    elif _row[&#34;variable_type&#34;] == &#34;enumerated&#34;:
                        # do some logic here to fill enumerated-specific field in template
                        value_set = _constraints[&#34;value_set&#34;].split(
                            &#34;, &#34;)

                        # init enumerated-form here:
                        enumerated_value_set = []

                        # loop over value_set
                        for _val in value_set:
                            enumerated_value_set.append({
                                &#34;definitions&#34;: [{
                                    &#34;designation&#34;: _val,
                                    &#34;definition&#34;: _val,
                                    &#34;language&#34;: &#34;en&#34;
                                }],
                                &#34;value&#34;: _val
                            })

                        valuedomain_temp[&#34;permittedValues&#34;] = enumerated_value_set

                    elif _row[&#34;variable_type&#34;] in [&#34;float&#34;, &#34;integer&#34;]:
                        valuedomain_temp[&#34;numeric&#34;][&#34;type&#34;] = _row[&#34;variable_type&#34;].upper(
                        )
                        # fill numeric-specific field in template
                        valuedomain_temp[&#34;numeric&#34;][&#34;minimum&#34;] = _constraints[&#34;range&#34;][&#34;min&#34;]
                        valuedomain_temp[&#34;numeric&#34;][&#34;maximum&#34;] = _constraints[&#34;range&#34;][&#34;max&#34;]
                        valuedomain_temp[&#34;numeric&#34;][&#34;unitOfMeasure&#34;] = _constraints[&#34;range&#34;][&#34;unit&#34;]

                        valuedomain_temp[&#34;numeric&#34;][&#34;useMinimum&#34;] = True
                        valuedomain_temp[&#34;numeric&#34;][&#34;useMaximum&#34;] = True

                    # add definition template to basetemp
                    de_basetemp[&#34;valueDomain&#34;] = valuedomain_temp

                except Exception as e:
                    logging.error(e)
                    valuedomain_temp = copy.deepcopy(
                        self._de_valuedomain_template_)
                    valuedomain_temp[&#34;text&#34;][&#34;useRegEx&#34;] = False
                    de_basetemp[&#34;valueDomain&#34;] = valuedomain_temp

                element_url = up.urljoin(
                    self.base_url,
                    &#34;element&#34;
                )
                response = requests.post(
                    url=element_url,
                    data=json.dumps(de_basetemp),
                    headers=self.header
                )
                logging.info(response)

    def read_csv_mdr(self, separator: str):
        if separator not in [&#34;;&#34;, &#34;,&#34;]:
            msg = &#34;Separator of CSV-file must be &#39;;&#39; or &#39;,&#39;&#34;
            logging.error(msg)
            raise Exception(msg)
        self.database = pd.read_csv(
            filepath_or_buffer=self.csv_file_name,
            sep=separator,
            keep_default_na=False
        )

    @staticmethod
    def post_to_api(url, data, header):
        logging.info(&#34;API post: {}&#34;.format(url))
        r = requests.post(
            url=url,
            data=data,
            headers=header
        )
        return r

    def init_template_elements(self):

        self._de_definition_json_template = {
            &#34;designation&#34;: [],
            &#34;definition&#34;: [],
            &#34;language&#34;: &#34;en&#34;
        }

        self._de_valuedomain_template_string = {
            &#34;type&#34;: &#34;STRING&#34;,
            &#34;text&#34;: {
                &#34;useRegEx&#34;: &#34;&#34;,
                &#34;regEx&#34;: &#34;&#34;,
                &#34;useMaximumLength&#34;: True,
                &#34;maximumLength&#34;: int()
            }
        }

        # use &#34;string&#34;, when no &#34;variable_type&#34; defined
        self._de_valuedomain_template_ = self._de_valuedomain_template_string

        # update datetime template correctly #done
        # above: fill correctly with info from csv
        self._de_valuedomain_template_datetime = {
            &#34;type&#34;: &#34;DATETIME&#34;,
            &#34;datetime&#34;: {
                &#34;date&#34;: &#34;&#34;,
                &#34;time&#34;: &#34;&#34;,
                &#34;hourFormat&#34;: &#34;&#34;
            }
        }

        # update enumerated template correctly #not possible in current status
        # above: fill correctly with info from csv
        self._de_valuedomain_template_enumerated = {
            &#34;type&#34;: &#34;ENUMERATED&#34;,
            &#34;permittedValues&#34;: &#34;&#34;
        }

        # update float template correctly
        # above: fill correctly with info from csv
        self._de_valuedomain_template_float = {
            &#34;type&#34;: &#34;NUMERIC&#34;,
            &#34;numeric&#34;: {
                &#34;type&#34;: &#34;&#34;,
                &#34;useMinimum&#34;: &#34;&#34;,  # bool
                &#34;useMaximum&#34;: &#34;&#34;,  # bool
                &#34;unitOfMeasure&#34;: &#34;&#34;,  # string
                &#34;minimum&#34;: &#34;&#34;,  # numeric/float
                &#34;maximum&#34;: &#34;&#34;  # numeric/float
            }
        }

        self._de_valuedomain_template_integer = self._de_valuedomain_template_float

        self._de_slot_template = {
            &#34;name&#34;: &#34;&#34;,
            &#34;value&#34;: &#34;&#34;
        }

    def init_templates(self):
        # init template elements
        self.init_template_elements()

        # data element template
        self._de_json_template = {
            &#34;identification&#34;: {
                &#34;elementType&#34;: &#34;DATAELEMENT&#34;,
                &#34;namespaceUrn&#34;: &#34;&#34;,
                &#34;status&#34;: &#34;RELEASED&#34;
            },
            &#34;definitions&#34;: [],
            &#34;slots&#34;: [],
            &#34;conceptAssociations&#34;: []
        }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dqa_mdr_connector.api_connection.ApiConnector" href="api_connection.html#dqa_mdr_connector.api_connection.ApiConnector">ApiConnector</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dqa_mdr_connector.update_mdr.UpdateMDR.post_to_api"><code class="name flex">
<span>def <span class="ident">post_to_api</span></span>(<span>url, data, header)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def post_to_api(url, data, header):
    logging.info(&#34;API post: {}&#34;.format(url))
    r = requests.post(
        url=url,
        data=data,
        headers=header
    )
    return r</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dqa_mdr_connector.update_mdr.UpdateMDR.init_template_elements"><code class="name flex">
<span>def <span class="ident">init_template_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_template_elements(self):

    self._de_definition_json_template = {
        &#34;designation&#34;: [],
        &#34;definition&#34;: [],
        &#34;language&#34;: &#34;en&#34;
    }

    self._de_valuedomain_template_string = {
        &#34;type&#34;: &#34;STRING&#34;,
        &#34;text&#34;: {
            &#34;useRegEx&#34;: &#34;&#34;,
            &#34;regEx&#34;: &#34;&#34;,
            &#34;useMaximumLength&#34;: True,
            &#34;maximumLength&#34;: int()
        }
    }

    # use &#34;string&#34;, when no &#34;variable_type&#34; defined
    self._de_valuedomain_template_ = self._de_valuedomain_template_string

    # update datetime template correctly #done
    # above: fill correctly with info from csv
    self._de_valuedomain_template_datetime = {
        &#34;type&#34;: &#34;DATETIME&#34;,
        &#34;datetime&#34;: {
            &#34;date&#34;: &#34;&#34;,
            &#34;time&#34;: &#34;&#34;,
            &#34;hourFormat&#34;: &#34;&#34;
        }
    }

    # update enumerated template correctly #not possible in current status
    # above: fill correctly with info from csv
    self._de_valuedomain_template_enumerated = {
        &#34;type&#34;: &#34;ENUMERATED&#34;,
        &#34;permittedValues&#34;: &#34;&#34;
    }

    # update float template correctly
    # above: fill correctly with info from csv
    self._de_valuedomain_template_float = {
        &#34;type&#34;: &#34;NUMERIC&#34;,
        &#34;numeric&#34;: {
            &#34;type&#34;: &#34;&#34;,
            &#34;useMinimum&#34;: &#34;&#34;,  # bool
            &#34;useMaximum&#34;: &#34;&#34;,  # bool
            &#34;unitOfMeasure&#34;: &#34;&#34;,  # string
            &#34;minimum&#34;: &#34;&#34;,  # numeric/float
            &#34;maximum&#34;: &#34;&#34;  # numeric/float
        }
    }

    self._de_valuedomain_template_integer = self._de_valuedomain_template_float

    self._de_slot_template = {
        &#34;name&#34;: &#34;&#34;,
        &#34;value&#34;: &#34;&#34;
    }</code></pre>
</details>
</dd>
<dt id="dqa_mdr_connector.update_mdr.UpdateMDR.init_templates"><code class="name flex">
<span>def <span class="ident">init_templates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_templates(self):
    # init template elements
    self.init_template_elements()

    # data element template
    self._de_json_template = {
        &#34;identification&#34;: {
            &#34;elementType&#34;: &#34;DATAELEMENT&#34;,
            &#34;namespaceUrn&#34;: &#34;&#34;,
            &#34;status&#34;: &#34;RELEASED&#34;
        },
        &#34;definitions&#34;: [],
        &#34;slots&#34;: [],
        &#34;conceptAssociations&#34;: []
    }</code></pre>
</details>
</dd>
<dt id="dqa_mdr_connector.update_mdr.UpdateMDR.read_csv_mdr"><code class="name flex">
<span>def <span class="ident">read_csv_mdr</span></span>(<span>self, separator: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_csv_mdr(self, separator: str):
    if separator not in [&#34;;&#34;, &#34;,&#34;]:
        msg = &#34;Separator of CSV-file must be &#39;;&#39; or &#39;,&#39;&#34;
        logging.error(msg)
        raise Exception(msg)
    self.database = pd.read_csv(
        filepath_or_buffer=self.csv_file_name,
        sep=separator,
        keep_default_na=False
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dqa_mdr_connector" href="index.html">dqa_mdr_connector</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dqa_mdr_connector.update_mdr.UpdateMDR" href="#dqa_mdr_connector.update_mdr.UpdateMDR">UpdateMDR</a></code></h4>
<ul class="">
<li><code><a title="dqa_mdr_connector.update_mdr.UpdateMDR.init_template_elements" href="#dqa_mdr_connector.update_mdr.UpdateMDR.init_template_elements">init_template_elements</a></code></li>
<li><code><a title="dqa_mdr_connector.update_mdr.UpdateMDR.init_templates" href="#dqa_mdr_connector.update_mdr.UpdateMDR.init_templates">init_templates</a></code></li>
<li><code><a title="dqa_mdr_connector.update_mdr.UpdateMDR.post_to_api" href="#dqa_mdr_connector.update_mdr.UpdateMDR.post_to_api">post_to_api</a></code></li>
<li><code><a title="dqa_mdr_connector.update_mdr.UpdateMDR.read_csv_mdr" href="#dqa_mdr_connector.update_mdr.UpdateMDR.read_csv_mdr">read_csv_mdr</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>